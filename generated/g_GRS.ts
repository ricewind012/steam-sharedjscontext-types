export interface g_GRS {
	m_bClipLoadingTriggered: boolean;
	m_bEnoughDiskSpace: boolean;
	m_bLoadingAppsWithBackgroundVideo: boolean;
	m_bLoadingClips: boolean;
	m_clipExportProgress: Map<any, any>;
	m_clips: Map<
		string,
		{
			clip_id: string;
			date_clipped: number;
			date_recorded: number;
			duration_ms: string;
			file_size: string;
			game_id: string;
			start_offset_ms: string;
			start_timeline_id: string;
			temporary: boolean;
			thumbnail_height: number;
			thumbnail_url: string;
			thumbnail_width: number;
		}
	>;
	m_clipsGroupByGame: Map<
		string,
		{
			0: {
				clip_id: string;
				date_clipped: number;
				date_recorded: number;
				duration_ms: string;
				file_size: string;
				game_id: string;
				start_offset_ms: string;
				start_timeline_id: string;
				temporary: boolean;
				thumbnail_height: number;
				thumbnail_url: string;
				thumbnail_width: number;
			};
			1: {
				clip_id: string;
				date_clipped: number;
				date_recorded: number;
				duration_ms: string;
				file_size: string;
				game_id: string;
				start_offset_ms: string;
				start_timeline_id: string;
				temporary: boolean;
				thumbnail_height: number;
				thumbnail_url: string;
				thumbnail_width: number;
			};
			2: {
				clip_id: string;
				date_clipped: number;
				date_recorded: number;
				duration_ms: string;
				file_size: string;
				game_id: string;
				start_offset_ms: string;
				start_timeline_id: string;
				temporary: boolean;
				thumbnail_height: number;
				thumbnail_url: string;
				thumbnail_width: number;
			};

			function();
			function();
			function(t, r);
			function(t, r);
			function(t, r);
			function(t, r);
			function(t, r);
			function(t, r);
			function();
			function(t, r);
			function(t, r);
			function();
			function();
			function();
			function();
			function(t, r);
			function();
			function();
			function();
			function();
			function();
			function();
			function();
			function(t, r);
			function();
			function(e, t);
			function();
			function(t, r);
			function();
			function();
			function();
			function();
			function();
		}
	>;
	m_currentlyExportingClip: any;
	m_fnGetAchievementInfo(...args: any[]);
	m_mapActiveTimelines: Map<any, any>;
	m_mapClipLoaders: Map<
		string,
		{
			loader: {
				m_bInitialized: boolean;
				m_clipID: string;
				m_fnTimelineURLBuilder(...args: any[]);
				m_gameID: string;
				m_mapRunningTimelines: Map<any, any>;
				m_mapTimelineData: Map<any, any>;
				m_rgListeners: any[];
				m_rgTimelineMetadata: { undefined }[];
				m_schUpdateRunning: {
					m_fnCallback: any;
					m_schTimer: any;

					Cancel();
					IsScheduled();
					Schedule(e, t);
				};
				m_ulFirstTimelineOffsetMS: number;

				AddEventListener(e);
				AddEventToTimeline(e, t, r, n, i, a, s, o);
				AddRunningTimeline(e, t, r);
				AddRunningTimelineEntry(e);
				AddUserMarker(e, t, r, n);
				AdvanceEntriesIndex(e);
				AdvanceGameModeIndex(e);
				AdvanceIterator(e, t);
				BInitialized();
				BIsTimelineRunning(e);
				BRecordingHasZeroOffset(e);
				ClampGlobalRangeToTimeline(e, t, r);
				ConvertGlobaOffsetToRecordingAndRelativeOffset(e);
				ConvertRecordingOffsetToGlobalOffset(e, t, r);
				ConvertRecordingTimeMStoPreTrimTimeMS(e, t);
				CreateGlobalRangeForTimeline(e, t, r, n);
				CreateTimelineIterator(e, t);
				FindRangeEventsAtGlobalMS(e);
				FindRecordingAndOffsetForEntry(e): Promise<any>;
				FindTimelineAtOffset(e, t);
				FireEvent(e, ...t);
				GenerateClipNameFromTimeline(e, t, r, n): Promise<any>;
				GenerateNamePartsFromTimeline(e, t, r, n): Promise<any>;
				GetClipID();
				GetClosestNextEntryInGlobalTimeline(e);
				GetClosestNextEntryInTimeline(e, t);
				GetClosestNextRecordingInGlobalTimeline(e);
				GetClosestPreviousEntryInGlobalTimeline(e);
				GetClosestPreviousEntryInTimeline(e, t);
				GetClosestPreviousRecordingInGlobalTimeline(e);
				GetEndOfRecordingsMS();
				GetFirstRecording();
				GetFirstRecordingOfLastTimelineSession();
				GetGameID();
				GetGlobalOffsetDataForTimeline(e, t);
				GetGlobalTimelineEndMS();
				GetIteratorGameMode(e);
				GetIteratorTimelineState(e);
				GetNextRecording(e);
				GetRunningTimelineDurationMS(e);
				GetRunningTimelineForRecording(e, t);
				GetStateDescriptionAtGlobalMS(e);
				GetTimelineData(e);
				GetTimelineDataOrStartLoad(e);
				GetTimelineDateMS(e, t);
				GetTimelineMetadata(e);
				GetTimelineMetadataIndex(e);
				GetTimelineOffsetFromGlobal(e, t);
				GetTimelineStartBeforeGlobalZeroMS(e);
				GetTimelines();
				GetTotalRecordingDuration();
				HasIteratorReachedEnd(e);
				InsertEntryIntoTimelineSorted(e, t);
				IsActiveRecording(e);
				IsActiveTimeline(e);
				LoadTimelineData(e): Promise<any>;
				LoadTimelinesForBackgroundVideo(e): Promise<any>;
				LoadTimelinesForClip(e): Promise<any>;
				LoadTimelinesForSharedClip(e);
				LoadTimelinesForTestClip(e, t, r, n);
				LoadTimelinesForTestGame(e, t);
				MakeRelativeToTimelineEndIfActive(e, t);
				ProcessTimelineEntries(e);
				RecordingSessionChanged(e);
				RemoveTimelineEvent(e, t);
				RemoveUserMarker(e, t);
				RunningTimelineStopped(e, t);
				SetPreloadedTimelines(e, t, r, n, i);
				SetTimelineData(e, t);
				TimelineDeleted(e);
				UpdateTimelineMetadata(e);
				UpdateUserMarker(e, t, r);
			};
			nRefCount: number;
		}
	>;
	m_mapManualRecordingCallbacks: Map<any, any>;
	m_mapSharedClipLoaders: Map<any, any>;
	m_mapTimelineLoaders: Map<
		string,
		{
			loader: {
				m_bInitialized: boolean;
				m_clipID: any;
				m_fnTimelineURLBuilder(...args: any[]);
				m_gameID: string;
				m_mapRunningTimelines: Map<any, any>;
				m_mapTimelineData: Map<any, any>;
				m_rgListeners: any[];
				m_rgTimelineMetadata: { undefined }[];
				m_schUpdateRunning: {
					m_fnCallback: any;
					m_schTimer: any;

					Cancel();
					IsScheduled();
					Schedule(e, t);
				};
				m_ulFirstTimelineOffsetMS: number;

				AddEventListener(e);
				AddEventToTimeline(e, t, r, n, i, a, s, o);
				AddRunningTimeline(e, t, r);
				AddRunningTimelineEntry(e);
				AddUserMarker(e, t, r, n);
				AdvanceEntriesIndex(e);
				AdvanceGameModeIndex(e);
				AdvanceIterator(e, t);
				BInitialized();
				BIsTimelineRunning(e);
				BRecordingHasZeroOffset(e);
				ClampGlobalRangeToTimeline(e, t, r);
				ConvertGlobaOffsetToRecordingAndRelativeOffset(e);
				ConvertRecordingOffsetToGlobalOffset(e, t, r);
				ConvertRecordingTimeMStoPreTrimTimeMS(e, t);
				CreateGlobalRangeForTimeline(e, t, r, n);
				CreateTimelineIterator(e, t);
				FindRangeEventsAtGlobalMS(e);
				FindRecordingAndOffsetForEntry(e): Promise<any>;
				FindTimelineAtOffset(e, t);
				FireEvent(e, ...t);
				GenerateClipNameFromTimeline(e, t, r, n): Promise<any>;
				GenerateNamePartsFromTimeline(e, t, r, n): Promise<any>;
				GetClipID();
				GetClosestNextEntryInGlobalTimeline(e);
				GetClosestNextEntryInTimeline(e, t);
				GetClosestNextRecordingInGlobalTimeline(e);
				GetClosestPreviousEntryInGlobalTimeline(e);
				GetClosestPreviousEntryInTimeline(e, t);
				GetClosestPreviousRecordingInGlobalTimeline(e);
				GetEndOfRecordingsMS();
				GetFirstRecording();
				GetFirstRecordingOfLastTimelineSession();
				GetGameID();
				GetGlobalOffsetDataForTimeline(e, t);
				GetGlobalTimelineEndMS();
				GetIteratorGameMode(e);
				GetIteratorTimelineState(e);
				GetNextRecording(e);
				GetRunningTimelineDurationMS(e);
				GetRunningTimelineForRecording(e, t);
				GetStateDescriptionAtGlobalMS(e);
				GetTimelineData(e);
				GetTimelineDataOrStartLoad(e);
				GetTimelineDateMS(e, t);
				GetTimelineMetadata(e);
				GetTimelineMetadataIndex(e);
				GetTimelineOffsetFromGlobal(e, t);
				GetTimelineStartBeforeGlobalZeroMS(e);
				GetTimelines();
				GetTotalRecordingDuration();
				HasIteratorReachedEnd(e);
				InsertEntryIntoTimelineSorted(e, t);
				IsActiveRecording(e);
				IsActiveTimeline(e);
				LoadTimelineData(e): Promise<any>;
				LoadTimelinesForBackgroundVideo(e): Promise<any>;
				LoadTimelinesForClip(e): Promise<any>;
				LoadTimelinesForSharedClip(e);
				LoadTimelinesForTestClip(e, t, r, n);
				LoadTimelinesForTestGame(e, t);
				MakeRelativeToTimelineEndIfActive(e, t);
				ProcessTimelineEntries(e);
				RecordingSessionChanged(e);
				RemoveTimelineEvent(e, t);
				RemoveUserMarker(e, t);
				RunningTimelineStopped(e, t);
				SetPreloadedTimelines(e, t, r, n, i);
				SetTimelineData(e, t);
				TimelineDeleted(e);
				UpdateTimelineMetadata(e);
				UpdateUserMarker(e, t, r);
			};
			nRefCount: number;
		}
	>;
	m_recordingState: any;
	m_rgAppsWithBackgroundVideo: {
		file_size: string;
		game_id: string;
		is_active: boolean;
		most_recent_start_time: number;
		timeline_duration_seconds: number;
		video_duration_seconds: number;
	}[];
	m_strLastClipID: any;
	m_transport: {
		MakeReady(...args: any[]);
		SendMsg(e, t, n);
		SendNotification(e, t);
	};

	BEnoughDiskSpace();
	BLoadingAppsWithBackgroundVideo();
	BLoadingClips();
	CheckEnoughDiskSpace(): Promise<any>;
	GetAppsWithBackgroundVideo();
	GetAvailableDiskSpace(): Promise<any>;
	GetBestClipTitle(e);
	GetClipExportProgress(e);
	GetClipIDs(e);
	GetClipSummaries(e);
	GetClipSummariesForGame(e);
	GetClipSummary(e);
	GetCurrentExportingClip();
	GetLastClip();
	GetRecordingHighlights(e, t): Promise<any>;
	GetRecordingState();
	GetTotalDiskSpaceUsage(e, t): Promise<any>;
	Init(e, t): Promise<any>;
	InternalAddClipSummary(e);
	LazyLoadClips(): Promise<any>;
	LoadAppsWithBackgroundVideo(): Promise<any>;
	ManuallyDeleteRecordingForApps(e);
	ReloadAppsWithBackgroundVideoIfNecessary(e);
	ReportClipRange(e, t, r, n, i);
	ReportClipShare(e, t, r, n, i);
}
